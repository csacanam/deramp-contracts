// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "../interfaces/ITreasuryManager.sol";
import "../interfaces/IAccessManager.sol";
import "../storage/DerampStorage.sol";

contract TreasuryManager is Pausable, ITreasuryManager {
    using SafeERC20 for IERC20;

    DerampStorage public immutable storageContract;
    IAccessManager public immutable accessManager;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;
    bytes32 public constant TREASURY_MANAGER_ROLE =
        keccak256("TREASURY_MANAGER_ROLE");

    modifier onlyTreasuryManager() {
        require(
            accessManager.hasRole(TREASURY_MANAGER_ROLE, msg.sender),
            "Not treasury manager"
        );
        _;
    }

    modifier onlyOwner() {
        require(
            accessManager.hasRole(DEFAULT_ADMIN_ROLE, msg.sender),
            "Not owner"
        );
        _;
    }

    constructor(address _storage, address _accessManager) {
        storageContract = DerampStorage(_storage);
        accessManager = IAccessManager(_accessManager);
    }

    // === TREASURY WALLET MANAGEMENT ===

    function addTreasuryWallet(
        address wallet,
        string calldata description
    ) external onlyTreasuryManager {
        require(wallet != address(0), "Invalid wallet address");
        // Check if wallet already exists by checking if it's in the list
        address[] memory existingWallets = storageContract
            .getTreasuryWalletsList();
        for (uint256 i = 0; i < existingWallets.length; i++) {
            require(existingWallets[i] != wallet, "Wallet already exists");
        }

        IDerampStorage.TreasuryWallet memory treasuryWallet = IDerampStorage
            .TreasuryWallet({
                wallet: wallet,
                isActive: true,
                addedAt: block.timestamp,
                description: description
            });

        storageContract.setTreasuryWallet(wallet, treasuryWallet);

        emit IDerampStorage.TreasuryWalletAdded(wallet, description);
    }

    function removeTreasuryWallet(address wallet) external onlyTreasuryManager {
        (address walletAddr, bool isActive, , ) = storageContract
            .treasuryWallets(wallet);
        require(walletAddr != address(0) && isActive, "Wallet not found");

        storageContract.removeTreasuryWalletFromList(wallet);

        emit IDerampStorage.TreasuryWalletRemoved(wallet);
    }

    function setTreasuryWalletStatus(
        address wallet,
        bool isActive
    ) external onlyTreasuryManager {
        (address walletAddr, , , ) = storageContract.treasuryWallets(wallet);
        require(walletAddr != address(0), "Wallet not found");

        storageContract.setTreasuryWalletStatus(wallet, isActive);

        emit IDerampStorage.TreasuryWalletStatusChanged(wallet, isActive);
    }

    function updateTreasuryWalletDescription(
        address wallet,
        string calldata newDescription
    ) external onlyTreasuryManager {
        (address walletAddr, , , ) = storageContract.treasuryWallets(wallet);
        require(walletAddr != address(0), "Wallet not found");

        IDerampStorage.TreasuryWallet memory treasuryWallet = storageContract
            .getTreasuryWallet(wallet);
        treasuryWallet.description = newDescription;

        storageContract.updateTreasuryWallet(wallet, treasuryWallet);

        emit IDerampStorage.TreasuryWalletUpdated(wallet, newDescription);
    }

    // === SERVICE FEE WITHDRAWALS ===

    function withdrawServiceFeesToTreasury(
        address token,
        uint256 amount,
        address treasuryWallet
    ) external onlyTreasuryManager whenNotPaused {
        require(amount > 0, "Amount must be greater than 0");
        require(
            this.isTreasuryWallet(treasuryWallet),
            "Invalid treasury wallet"
        );
        require(
            storageContract.getTreasuryWallet(treasuryWallet).isActive,
            "Treasury wallet not active"
        );
        require(
            storageContract.getServiceFeeBalance(token) >= amount,
            "Insufficient service fee balance"
        );

        // Update balance
        storageContract.subtractServiceFeeBalance(token, amount);

        // Transfer tokens
        IERC20(token).safeTransfer(treasuryWallet, amount);

        // Create withdrawal record
        IDerampStorage.WithdrawalRecord memory record = IDerampStorage
            .WithdrawalRecord({
                token: token,
                amount: amount,
                to: treasuryWallet,
                initiatedBy: msg.sender,
                withdrawalType: IDerampStorage.WithdrawalType.SERVICE_FEE,
                createdAt: block.timestamp,
                invoiceId: bytes32(0)
            });

        storageContract.addWithdrawalRecord(record);

        emit IDerampStorage.ServiceFeeWithdrawal(treasuryWallet, token, amount);
    }

    function withdrawAllServiceFeesToTreasury(
        address token,
        address treasuryWallet
    ) external onlyTreasuryManager whenNotPaused {
        uint256 balance = storageContract.getServiceFeeBalance(token);
        require(balance > 0, "No service fees to withdraw");

        // Inline withdrawServiceFeesToTreasury logic
        require(
            this.isTreasuryWallet(treasuryWallet),
            "Invalid treasury wallet"
        );
        require(
            storageContract.getTreasuryWallet(treasuryWallet).isActive,
            "Treasury wallet not active"
        );
        require(
            storageContract.getServiceFeeBalance(token) >= balance,
            "Insufficient service fee balance"
        );

        // Update balance
        storageContract.subtractServiceFeeBalance(token, balance);

        // Transfer tokens
        IERC20(token).safeTransfer(treasuryWallet, balance);

        // Create withdrawal record
        IDerampStorage.WithdrawalRecord memory record = IDerampStorage
            .WithdrawalRecord({
                token: token,
                amount: balance,
                to: treasuryWallet,
                initiatedBy: msg.sender,
                withdrawalType: IDerampStorage.WithdrawalType.SERVICE_FEE,
                createdAt: block.timestamp,
                invoiceId: bytes32(0)
            });

        storageContract.addWithdrawalRecord(record);

        emit IDerampStorage.ServiceFeeWithdrawal(
            treasuryWallet,
            token,
            balance
        );
    }

    function withdrawMultipleServiceFeesToTreasury(
        address[] calldata tokens,
        uint256[] calldata amounts,
        address treasuryWallet
    ) external onlyTreasuryManager whenNotPaused {
        require(tokens.length == amounts.length, "Array length mismatch");
        require(
            this.isTreasuryWallet(treasuryWallet),
            "Invalid treasury wallet"
        );
        require(
            storageContract.getTreasuryWallet(treasuryWallet).isActive,
            "Treasury wallet not active"
        );

        for (uint256 i = 0; i < tokens.length; i++) {
            if (
                amounts[i] > 0 &&
                storageContract.getServiceFeeBalance(tokens[i]) >= amounts[i]
            ) {
                // Inline withdrawServiceFeesToTreasury logic
                require(
                    storageContract.getServiceFeeBalance(tokens[i]) >=
                        amounts[i],
                    "Insufficient service fee balance"
                );

                // Update balance
                storageContract.subtractServiceFeeBalance(
                    tokens[i],
                    amounts[i]
                );

                // Transfer tokens
                IERC20(tokens[i]).safeTransfer(treasuryWallet, amounts[i]);

                // Create withdrawal record
                IDerampStorage.WithdrawalRecord memory record = IDerampStorage
                    .WithdrawalRecord({
                        token: tokens[i],
                        amount: amounts[i],
                        to: treasuryWallet,
                        initiatedBy: msg.sender,
                        withdrawalType: IDerampStorage
                            .WithdrawalType
                            .SERVICE_FEE,
                        createdAt: block.timestamp,
                        invoiceId: bytes32(0)
                    });

                storageContract.addWithdrawalRecord(record);

                emit IDerampStorage.ServiceFeeWithdrawal(
                    treasuryWallet,
                    tokens[i],
                    amounts[i]
                );
            }
        }
    }

    function withdrawAllServiceFeesToTreasuryMultiple(
        address[] calldata tokens,
        address treasuryWallet
    ) external onlyTreasuryManager whenNotPaused {
        require(
            this.isTreasuryWallet(treasuryWallet),
            "Invalid treasury wallet"
        );
        require(
            storageContract.getTreasuryWallet(treasuryWallet).isActive,
            "Treasury wallet not active"
        );

        for (uint256 i = 0; i < tokens.length; i++) {
            uint256 balance = storageContract.getServiceFeeBalance(tokens[i]);
            if (balance > 0) {
                // Inline withdrawServiceFeesToTreasury logic
                require(
                    storageContract.getServiceFeeBalance(tokens[i]) >= balance,
                    "Insufficient service fee balance"
                );

                // Update balance
                storageContract.subtractServiceFeeBalance(tokens[i], balance);

                // Transfer tokens
                IERC20(tokens[i]).safeTransfer(treasuryWallet, balance);

                // Create withdrawal record
                IDerampStorage.WithdrawalRecord memory record = IDerampStorage
                    .WithdrawalRecord({
                        token: tokens[i],
                        amount: balance,
                        to: treasuryWallet,
                        initiatedBy: msg.sender,
                        withdrawalType: IDerampStorage
                            .WithdrawalType
                            .SERVICE_FEE,
                        createdAt: block.timestamp,
                        invoiceId: bytes32(0)
                    });

                storageContract.addWithdrawalRecord(record);

                emit IDerampStorage.ServiceFeeWithdrawal(
                    treasuryWallet,
                    tokens[i],
                    balance
                );
            }
        }
    }

    // === ADMIN WITHDRAWALS ===

    function adminWithdrawServiceFees(
        address token,
        uint256 amount,
        address to
    ) external onlyOwner whenNotPaused {
        require(amount > 0, "Amount must be greater than 0");
        require(to != address(0), "Invalid recipient");
        require(
            storageContract.getServiceFeeBalance(token) >= amount,
            "Insufficient service fee balance"
        );

        // Update balance
        storageContract.subtractServiceFeeBalance(token, amount);

        // Transfer tokens
        IERC20(token).safeTransfer(to, amount);

        // Create withdrawal record
        IDerampStorage.WithdrawalRecord memory record = IDerampStorage
            .WithdrawalRecord({
                token: token,
                amount: amount,
                to: to,
                initiatedBy: msg.sender,
                withdrawalType: IDerampStorage.WithdrawalType.SERVICE_FEE,
                createdAt: block.timestamp,
                invoiceId: bytes32(0)
            });

        storageContract.addWithdrawalRecord(record);

        emit IDerampStorage.ServiceFeeWithdrawal(to, token, amount);
    }

    // === TREASURY QUERIES ===

    function getTreasuryWallets()
        external
        view
        returns (IDerampStorage.TreasuryWallet[] memory)
    {
        return storageContract.getTreasuryWallets();
    }

    function getActiveTreasuryWallets()
        external
        view
        returns (address[] memory)
    {
        address[] memory allWallets = storageContract.getTreasuryWalletsList();
        address[] memory tempResults = new address[](allWallets.length);
        uint256 count = 0;

        for (uint256 i = 0; i < allWallets.length; i++) {
            (address walletAddr, bool isActive, , ) = storageContract
                .treasuryWallets(allWallets[i]);
            if (walletAddr != address(0) && isActive) {
                tempResults[count] = allWallets[i];
                count++;
            }
        }

        address[] memory results = new address[](count);
        for (uint256 i = 0; i < count; i++) {
            results[i] = tempResults[i];
        }

        return results;
    }

    function getTreasuryWallet(
        address wallet
    ) external view returns (IDerampStorage.TreasuryWallet memory) {
        return storageContract.getTreasuryWallet(wallet);
    }

    function isTreasuryWallet(address wallet) external view returns (bool) {
        (address walletAddr, , , ) = storageContract.treasuryWallets(wallet);
        return walletAddr != address(0);
    }

    function isTreasuryWalletActive(
        address wallet
    ) external view returns (bool) {
        (address walletAddr, bool isActive, , ) = storageContract
            .treasuryWallets(wallet);
        return walletAddr != address(0) && isActive;
    }

    // === WITHDRAWAL HISTORY QUERIES ===

    function getTreasuryWithdrawals()
        external
        view
        returns (IDerampStorage.WithdrawalRecord[] memory)
    {
        return storageContract.getTreasuryWithdrawals();
    }

    function getServiceFeeWithdrawals()
        external
        view
        returns (IDerampStorage.WithdrawalRecord[] memory)
    {
        return storageContract.getServiceFeeWithdrawals();
    }

    function getTreasuryWithdrawalsByWallet(
        address wallet
    ) external view returns (IDerampStorage.WithdrawalRecord[] memory) {
        IDerampStorage.WithdrawalRecord[]
            memory allWithdrawals = storageContract.getTreasuryWithdrawals();
        IDerampStorage.WithdrawalRecord[]
            memory tempResults = new IDerampStorage.WithdrawalRecord[](
                allWithdrawals.length
            );
        uint256 count = 0;

        for (uint256 i = 0; i < allWithdrawals.length; i++) {
            if (allWithdrawals[i].to == wallet) {
                tempResults[count] = allWithdrawals[i];
                count++;
            }
        }

        IDerampStorage.WithdrawalRecord[]
            memory results = new IDerampStorage.WithdrawalRecord[](count);
        for (uint256 i = 0; i < count; i++) {
            results[i] = tempResults[i];
        }

        return results;
    }

    function getTreasuryWithdrawalsByToken(
        address token
    ) external view returns (IDerampStorage.WithdrawalRecord[] memory) {
        IDerampStorage.WithdrawalRecord[]
            memory allWithdrawals = storageContract.getTreasuryWithdrawals();
        IDerampStorage.WithdrawalRecord[]
            memory tempResults = new IDerampStorage.WithdrawalRecord[](
                allWithdrawals.length
            );
        uint256 count = 0;

        for (uint256 i = 0; i < allWithdrawals.length; i++) {
            if (allWithdrawals[i].token == token) {
                tempResults[count] = allWithdrawals[i];
                count++;
            }
        }

        IDerampStorage.WithdrawalRecord[]
            memory results = new IDerampStorage.WithdrawalRecord[](count);
        for (uint256 i = 0; i < count; i++) {
            results[i] = tempResults[i];
        }

        return results;
    }

    // === TREASURY STATISTICS ===

    function getTreasuryStats()
        external
        view
        returns (
            uint256 totalWallets,
            uint256 activeWallets,
            uint256 totalWithdrawals,
            uint256 totalServiceFeeWithdrawals
        )
    {
        IDerampStorage.TreasuryWallet[] memory allWallets = storageContract
            .getTreasuryWallets();
        totalWallets = allWallets.length;

        for (uint256 i = 0; i < allWallets.length; i++) {
            if (allWallets[i].isActive) {
                activeWallets++;
            }
        }

        totalWithdrawals = storageContract.getTreasuryWithdrawals().length;
        totalServiceFeeWithdrawals = storageContract
            .getServiceFeeWithdrawals()
            .length;
    }

    function getTreasuryWithdrawalStatsByToken(
        address token
    )
        external
        view
        returns (
            uint256 totalAmount,
            uint256 totalCount,
            address[] memory wallets,
            uint256[] memory amounts
        )
    {
        IDerampStorage.WithdrawalRecord[] memory withdrawals = storageContract
            .getTreasuryWithdrawals();

        // Filter by token and count unique wallets
        address[] memory tempWallets = new address[](withdrawals.length);
        uint256[] memory tempAmounts = new uint256[](withdrawals.length);
        uint256 uniqueWallets = 0;

        for (uint256 i = 0; i < withdrawals.length; i++) {
            if (withdrawals[i].token == token) {
                totalAmount += withdrawals[i].amount;
                totalCount++;

                // Track per wallet
                bool found = false;
                for (uint256 j = 0; j < uniqueWallets; j++) {
                    if (tempWallets[j] == withdrawals[i].to) {
                        tempAmounts[j] += withdrawals[i].amount;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    tempWallets[uniqueWallets] = withdrawals[i].to;
                    tempAmounts[uniqueWallets] = withdrawals[i].amount;
                    uniqueWallets++;
                }
            }
        }

        wallets = new address[](uniqueWallets);
        amounts = new uint256[](uniqueWallets);
        for (uint256 i = 0; i < uniqueWallets; i++) {
            wallets[i] = tempWallets[i];
            amounts[i] = tempAmounts[i];
        }
    }

    /// @notice Get service fee withdrawal statistics
    /// @return totalWithdrawals Total number of service fee withdrawals
    /// @return totalAmountByToken Total amounts withdrawn by token
    /// @return tokens Array of tokens withdrawn
    /// @return treasuryWalletList Array of treasury wallets that received funds
    /// @return amountsByTreasury Amount sent to each treasury wallet by token
    function getServiceFeeWithdrawalStats()
        external
        view
        returns (
            uint256 totalWithdrawals,
            uint256[] memory totalAmountByToken,
            address[] memory tokens,
            address[] memory treasuryWalletList,
            uint256[][] memory amountsByTreasury
        )
    {
        uint256[] memory indices = storageContract.getServiceFeeWithdrawals();
        totalWithdrawals = indices.length;

        // Get unique tokens and treasury wallets
        address[] memory tempTokens = new address[](totalWithdrawals);
        address[] memory tempTreasuryWallets = new address[](totalWithdrawals);
        uint256 uniqueTokenCount = 0;
        uint256 uniqueTreasuryCount = 0;

        IDerampStorage.WithdrawalRecord[]
            memory withdrawalHistory = storageContract.getWithdrawalHistory();

        for (uint256 i = 0; i < indices.length; i++) {
            IDerampStorage.WithdrawalRecord
                memory withdrawal = withdrawalHistory[indices[i]];

            // Check for unique tokens
            bool tokenFound = false;
            for (uint256 j = 0; j < uniqueTokenCount; j++) {
                if (tempTokens[j] == withdrawal.token) {
                    tokenFound = true;
                    break;
                }
            }
            if (!tokenFound) {
                tempTokens[uniqueTokenCount] = withdrawal.token;
                uniqueTokenCount++;
            }

            // Check for unique treasury wallets
            bool treasuryFound = false;
            for (uint256 j = 0; j < uniqueTreasuryCount; j++) {
                if (tempTreasuryWallets[j] == withdrawal.to) {
                    treasuryFound = true;
                    break;
                }
            }
            if (!treasuryFound) {
                tempTreasuryWallets[uniqueTreasuryCount] = withdrawal.to;
                uniqueTreasuryCount++;
            }
        }

        // Create final arrays
        tokens = new address[](uniqueTokenCount);
        totalAmountByToken = new uint256[](uniqueTokenCount);
        treasuryWalletList = new address[](uniqueTreasuryCount);
        amountsByTreasury = new uint256[][](uniqueTreasuryCount);

        for (uint256 i = 0; i < uniqueTokenCount; i++) {
            tokens[i] = tempTokens[i];
        }

        for (uint256 i = 0; i < uniqueTreasuryCount; i++) {
            treasuryWalletList[i] = tempTreasuryWallets[i];
            amountsByTreasury[i] = new uint256[](uniqueTokenCount);
        }

        // Calculate amounts
        for (uint256 i = 0; i < indices.length; i++) {
            IDerampStorage.WithdrawalRecord
                memory withdrawal = withdrawalHistory[indices[i]];

            // Find token index
            uint256 tokenIndex = 0;
            for (uint256 j = 0; j < uniqueTokenCount; j++) {
                if (tokens[j] == withdrawal.token) {
                    tokenIndex = j;
                    break;
                }
            }

            // Find treasury index
            uint256 treasuryIndex = 0;
            for (uint256 j = 0; j < uniqueTreasuryCount; j++) {
                if (treasuryWalletList[j] == withdrawal.to) {
                    treasuryIndex = j;
                    break;
                }
            }

            totalAmountByToken[tokenIndex] += withdrawal.amount;
            amountsByTreasury[treasuryIndex][tokenIndex] += withdrawal.amount;
        }
    }

    // === SERVICE FEE BALANCE QUERIES ===

    function getServiceFeeBalance(
        address token
    ) external view returns (uint256) {
        return storageContract.getServiceFeeBalance(token);
    }

    function getServiceFeeBalances(
        address[] calldata tokens
    ) external view returns (uint256[] memory) {
        uint256[] memory balances = new uint256[](tokens.length);
        for (uint256 i = 0; i < tokens.length; i++) {
            balances[i] = storageContract.getServiceFeeBalance(tokens[i]);
        }
        return balances;
    }

    function getAllServiceFeeTokens() external view returns (address[] memory) {
        return storageContract.getServiceFeeTokens();
    }

    function getTotalServiceFeesCollected(
        address token
    ) external view returns (uint256) {
        // This would require tracking total collected fees, not just current balance
        // For now, we can sum current balance + total withdrawn
        uint256 currentBalance = storageContract.getServiceFeeBalance(token);
        uint256 totalWithdrawn = 0;

        IDerampStorage.WithdrawalRecord[] memory withdrawals = storageContract
            .getServiceFeeWithdrawals();
        for (uint256 i = 0; i < withdrawals.length; i++) {
            if (withdrawals[i].token == token) {
                totalWithdrawn += withdrawals[i].amount;
            }
        }

        return currentBalance + totalWithdrawn;
    }

    // === ADMIN FUNCTIONS ===

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function getAllTreasuryWallets() external view returns (address[] memory) {
        return storageContract.getTreasuryWalletsList();
    }

    // === SERVICE FEE WITHDRAWAL FUNCTIONS ===

    function withdrawServiceFeesToTreasury(
        address token,
        address to
    ) external onlyTreasuryManager whenNotPaused {
        require(
            (, bool isActive, , ) = storageContract.treasuryWallets(to); isActive,
            "Treasury wallet not active"
        );

        uint256 amount = storageContract.serviceFeeBalances(token);
        require(amount > 0, "No service fees to withdraw");

        storageContract.subtractFromServiceFeeBalance(token, amount);
        IERC20(token).safeTransfer(to, amount);

        // Create withdrawal record
        IDerampStorage.WithdrawalRecord memory record = IDerampStorage
            .WithdrawalRecord({
                token: token,
                amount: amount,
                to: to,
                initiatedBy: msg.sender,
                withdrawalType: IDerampStorage.WithdrawalType.SERVICE_FEE,
                createdAt: block.timestamp,
                invoiceId: bytes32(0)
            });

        uint256 index = storageContract.addWithdrawalRecord(record);
        storageContract.addServiceFeeWithdrawal(index);
        storageContract.addTreasuryWithdrawal(to, index);

        emit IDerampStorage.ServiceFeeWithdrawn(token, amount, to);
    }

    function withdrawAllServiceFeesToTreasury(
        address[] calldata tokens,
        address to
    ) external onlyTreasuryManager whenNotPaused {
        require(tokens.length > 0, "No tokens provided");
        require(
            (, bool isActive, , ) = storageContract.treasuryWallets(to); isActive,
            "Treasury wallet not active"
        );

        uint256 totalWithdrawn = 0;

        for (uint256 i = 0; i < tokens.length; i++) {
            address token = tokens[i];
            uint256 amount = storageContract.serviceFeeBalances(token);

            if (amount == 0) {
                continue;
            }

            storageContract.subtractFromServiceFeeBalance(token, amount);
            IERC20(token).safeTransfer(to, amount);

            // Create withdrawal record
            IDerampStorage.WithdrawalRecord memory record = IDerampStorage
                .WithdrawalRecord({
                    token: token,
                    amount: amount,
                    to: to,
                    initiatedBy: msg.sender,
                    withdrawalType: IDerampStorage.WithdrawalType.SERVICE_FEE,
                    createdAt: block.timestamp,
                    invoiceId: bytes32(0)
                });

            uint256 index = storageContract.addWithdrawalRecord(record);
            storageContract.addServiceFeeWithdrawal(index);
            storageContract.addTreasuryWithdrawal(to, index);

            emit IDerampStorage.ServiceFeeWithdrawn(token, amount, to);
            totalWithdrawn++;
        }

        require(totalWithdrawn > 0, "No service fees to withdraw");
    }

    function withdrawServiceFees(
        address token,
        address to
    ) external onlyOwner whenNotPaused {
        uint256 amount = storageContract.serviceFeeBalances(token);
        require(amount > 0, "No service fees to withdraw");

        storageContract.subtractFromServiceFeeBalance(token, amount);
        IERC20(token).safeTransfer(to, amount);

        emit IDerampStorage.ServiceFeeWithdrawn(token, amount, to);
    }

    function withdrawAllServiceFees(
        address[] calldata tokens,
        address to
    ) external onlyOwner whenNotPaused {
        require(tokens.length > 0, "No tokens provided");
        uint256 totalWithdrawn = 0;

        for (uint256 i = 0; i < tokens.length; i++) {
            address token = tokens[i];
            uint256 amount = storageContract.serviceFeeBalances(token);

            if (amount == 0) {
                continue;
            }

            storageContract.subtractFromServiceFeeBalance(token, amount);
            IERC20(token).safeTransfer(to, amount);

            emit IDerampStorage.ServiceFeeWithdrawn(token, amount, to);
            totalWithdrawn++;
        }

        require(totalWithdrawn > 0, "No service fees to withdraw");
    }

    // === WITHDRAWAL QUERIES ===

    function getServiceFeeWithdrawalIndices()
        external
        view
        returns (uint256[] memory)
    {
        return storageContract.getServiceFeeWithdrawals();
    }

    function getRecentServiceFeeWithdrawals(
        uint256 limit
    ) external view returns (IDerampStorage.WithdrawalRecord[] memory) {
        uint256[] memory indices = storageContract.getServiceFeeWithdrawals();
        uint256 totalWithdrawals = indices.length;

        if (totalWithdrawals == 0) {
            return new IDerampStorage.WithdrawalRecord[](0);
        }

        uint256 resultSize = limit > totalWithdrawals
            ? totalWithdrawals
            : limit;
        IDerampStorage.WithdrawalRecord[]
            memory result = new IDerampStorage.WithdrawalRecord[](resultSize);
        IDerampStorage.WithdrawalRecord[] memory history = storageContract
            .getWithdrawalHistory();

        // Return from most recent to oldest
        for (uint256 i = 0; i < resultSize; i++) {
            uint256 withdrawalIndex = indices[totalWithdrawals - 1 - i];
            result[i] = history[withdrawalIndex];
        }

        return result;
    }

    function getTreasuryWithdrawalIndices(
        address treasuryWallet
    ) external view returns (uint256[] memory) {
        return storageContract.getTreasuryWithdrawals(treasuryWallet);
    }

    function getTreasuryWithdrawals(
        address treasuryWallet
    ) external view returns (IDerampStorage.WithdrawalRecord[] memory) {
        uint256[] memory indices = storageContract.getTreasuryWithdrawals(
            treasuryWallet
        );
        IDerampStorage.WithdrawalRecord[] memory history = storageContract
            .getWithdrawalHistory();
        IDerampStorage.WithdrawalRecord[]
            memory result = new IDerampStorage.WithdrawalRecord[](
                indices.length
            );

        for (uint256 i = 0; i < indices.length; i++) {
            result[i] = history[indices[i]];
        }

        return result;
    }

    function getRecentTreasuryWithdrawals(
        address treasuryWallet,
        uint256 limit
    ) external view returns (IDerampStorage.WithdrawalRecord[] memory) {
        uint256[] memory indices = storageContract.getTreasuryWithdrawals(
            treasuryWallet
        );
        uint256 totalWithdrawals = indices.length;

        if (totalWithdrawals == 0) {
            return new IDerampStorage.WithdrawalRecord[](0);
        }

        uint256 resultSize = limit > totalWithdrawals
            ? totalWithdrawals
            : limit;
        IDerampStorage.WithdrawalRecord[]
            memory result = new IDerampStorage.WithdrawalRecord[](resultSize);
        IDerampStorage.WithdrawalRecord[] memory history = storageContract
            .getWithdrawalHistory();

        // Return from most recent to oldest
        for (uint256 i = 0; i < resultSize; i++) {
            uint256 withdrawalIndex = indices[totalWithdrawals - 1 - i];
            result[i] = history[withdrawalIndex];
        }

        return result;
    }
}
